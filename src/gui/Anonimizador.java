package gui;

import com.csvreader.CsvReader;
import com.csvreader.CsvWriter;
import java.awt.Color;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.SwingWorker;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.table.DefaultTableModel;
import javax.swing.tree.DefaultTreeModel;
import org.supercsv.io.CsvMapReader;
import org.supercsv.io.ICsvMapReader;
import org.supercsv.prefs.CsvPreference;
import weka.clusterers.SimpleKMeans;
import weka.core.Instances;
import weka.core.converters.ConverterUtils;
import util.TaxoTree;
import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.RemoveType;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 * Class used to run the project and GUI.
 */
public class Anonimizador extends javax.swing.JFrame {

	/**
	 * The Constructor of the GUI - Creates a new form
	 */
	public Anonimizador() {
		tableModel = new DefaultTableModel(data, columnNames);
		treeModel = new DefaultTreeModel(null);
		try {
			// Set cross-platform Java L&F (also called "Metal")
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (UnsupportedLookAndFeelException | ClassNotFoundException | InstantiationException | IllegalAccessException e) {
			// handle exception
		}

		initComponents();
		//getContentPane().setBackground(Color.WHITE);
		jTabbedPane1.setVisible(false);
		//jButton5.setVisible(false);
		jPanel1.setVisible(false);
	}

	public ICsvMapReader mapReader;
	public FileReader fReader;
	public Vector<String> columnNames;
	public Vector<Vector<Object>> data;
	public DefaultTableModel tableModel;
	public DefaultTreeModel treeModel;
	public String[] headers;
	public String[] arrayOfX;

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFileChooser1 = new javax.swing.JFileChooser();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTable2 = new javax.swing.JTable();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel3 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTree1 = new javax.swing.JTree();
        jPanel2 = new javax.swing.JPanel();
        jButton5 = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jSpinner1 = new javax.swing.JSpinner();
        jLabel4 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        jButton6 = new javax.swing.JButton();
        jTextField3 = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        Open = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();

        jFileChooser1.setDialogTitle("Este es mi dialogo abierto");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jScrollPane3.setPreferredSize(new java.awt.Dimension(454, 200));

        jTable2.setModel(tableModel);
        jTable2.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        jScrollPane3.setViewportView(jTable2);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 462, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        jScrollPane1.setMinimumSize(new java.awt.Dimension(100, 20));
        jScrollPane1.setPreferredSize(new java.awt.Dimension(83, 100));

        jTree1.setModel(treeModel);
        jScrollPane1.setViewportView(jTree1);

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Taxonomy", jPanel3);

        jButton5.setText("Anonimizar");
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });

        jLabel3.setText("Anonimización k");

        jSpinner1.setPreferredSize(new java.awt.Dimension(100, 26));

        jLabel4.setText("Atributos nominales");

        jTextField1.setPreferredSize(new java.awt.Dimension(300, 26));
        jTextField1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField1ActionPerformed(evt);
            }
        });

        jButton6.setText("Calcular");
        jButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton6ActionPerformed(evt);
            }
        });

        jTextField3.setPreferredSize(new java.awt.Dimension(300, 26));
        jTextField3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField3ActionPerformed(evt);
            }
        });

        jLabel6.setText("Atributos quasi-identificadores");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                        .addGap(0, 346, Short.MAX_VALUE)
                        .addComponent(jButton5))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jButton6))
                            .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4)
                            .addComponent(jLabel3)
                            .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel6))
                        .addGap(0, 0, 0)))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jSpinner1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton6))
                .addGap(18, 18, 18)
                .addComponent(jButton5)
                .addContainerGap())
        );

        Open.setText("File");

        jMenuItem1.setText("Open");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        Open.add(jMenuItem1);

        jMenuItem2.setText("Exit");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        Open.add(jMenuItem2);

        jMenuBar1.add(Open);

        jMenu2.setText("Edit");
        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jTabbedPane1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTabbedPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

	/**
	 * This method is in charge of executing the load of the initial CSV.
	 *
	 * @param evt The event launched on the GUI
	 * @author Camilo Benavides
	 */
    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
		File workingDirectory = new File(System.getProperty("user.dir"));
		jFileChooser1.setCurrentDirectory(workingDirectory);
		jFileChooser1.setFileFilter(new CSVFileFilter());
		int returnVal = jFileChooser1.showOpenDialog(this);
		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = jFileChooser1.getSelectedFile();

			try {

				// place the document to the fReader
				fReader = new FileReader(file.getAbsolutePath());

				//Filling the table with CSV data
				mapReader = new CsvMapReader(fReader, CsvPreference.EXCEL_PREFERENCE);
				new SwingWorker<Void, Void>() {
					@Override
					protected Void doInBackground() throws Exception {
						loadData();
						jSpinner1.setValue(calculateKAnonimity());
						return null;
					}
				}.execute();

			} catch (IOException ex) {
				System.out.println("Problem accessing the file: " + file.getAbsolutePath());
			}
		} else {
			System.out.println("File access cancelled by user.");
		}
    }//GEN-LAST:event_jMenuItem1ActionPerformed

	/**
	 * This method is in charge of executing the exit of the program.
	 *
	 * @param evt The event launched on the GUI
	 * @author Camilo Benavides
	 */
    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
		System.exit(0);
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    private void jTextField1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField1ActionPerformed
		// TODO add your handling code here:
    }//GEN-LAST:event_jTextField1ActionPerformed

    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed
        // TODO add your handling code here:
        System.out.println(calculateKAnonimity());
        
        
        System.out.println(bestNumberOfClusters());
            try {
                filterFour(jTextField1.getText(), bestNumberOfClusters()+"");
            } catch (Exception ex) {
                Logger.getLogger(Anonimizador.class.getName()).log(Level.SEVERE, null, ex);
            }
        System.out.println(calculateKAnonimity());
    }//GEN-LAST:event_jButton5ActionPerformed

    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton6ActionPerformed
        List<Integer> quasiIds = new ArrayList<>();
		String quasis = jTextField3.getText();
		StringTokenizer strt = new StringTokenizer(quasis);
		while (strt.hasMoreTokens()) {
			String token = strt.nextToken(",");
			int id;
			try {
				id = Integer.parseInt(token);
			} catch (NumberFormatException e) {
				Logger.getLogger(Anonimizador.class.getName()).log(Level.ALL, null, e);
				throw new RuntimeException("Los índices deben ser numéricos.");
			}
			quasiIds.add(id);
		}
		jSpinner1.setValue(calculateKAnonimity(quasiIds));
    }//GEN-LAST:event_jButton6ActionPerformed

    private void jTextField3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField3ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextField3ActionPerformed

	/**
	 * This method load the Data that comes from the initial loaded CSV file.
	 *
	 * @author Camilo Benavides
	 */
	private void loadData() throws IOException {

		jTabbedPane1.setVisible(false);
		jPanel1.setVisible(false);
		try {
			headers = mapReader.getHeader(true);

			// Names of columns
			columnNames = new Vector<String>();
			for (String header : headers) {
				columnNames.add(header);
			}

			// Data of the table
			data = new Vector<Vector<Object>>();
			Map<String, String> row;
			while ((row = mapReader.read(headers)) != null) {
				Vector<Object> vector = new Vector<Object>();
				for (String header : headers) {
					vector.add(row.get(header));
				}
				data.add(vector);
			}

			// Filling the TableModel
			tableModel.setDataVector(data, columnNames);
			jTabbedPane1.setVisible(true);
			jPanel1.setVisible(true);
		} finally {
			//mapReader.close();
		}

	}

	/**
	 * This method is in charge of executing the filter one - Number identifier
	 * of different values.
	 *
	 * @param dataFilterOne Listing with comma-separated quasi-identifier
	 * identifiers
	 * @author Camilo Benavides
	 */
	private void filterOne(String dataFilterOne) {

		if (!dataFilterOne.equals("")) {

			System.out.println("The parameters for the first filter are NOT empty");

			String cuasiID = dataFilterOne;

			StringTokenizer st = new StringTokenizer(cuasiID, ",");

			try {
				filterOneProcedure(st);
				tableModel.fireTableDataChanged();
			} catch (IOException ex) {
				Logger.getLogger(Anonimizador.class.getName()).log(Level.SEVERE, null, ex);
			}

		} else {

			System.out.println("The parameters for the first filter are empty");
		}

	}

	/**
	 * This method is in charge of executing the filter two - Generalizer based
	 * on taxonomy.
	 *
	 * @param nominalAttributes Nominal attributes separated by commas.
	 * @param attributesToGeneralize Nominal attribute to generalize.
	 * @param generalizationLevel Level of generalization.
	 * @param taxonomyFilePath Absolute path to taxonomy file.
	 * @author David Villamizar
	 */
	private void filterTwo(String nominalAttributes, String attributesToGeneralize, String generalizationLevel, String taxonomyFilePath) {

		TaxoTree<String> t = parseTaxonomyFile(taxonomyFilePath);
		treeModel.setRoot(t);
		String indexStr = attributesToGeneralize;

		if (indexStr.isEmpty()) {
			System.out.println("Debe ponerse el índice del atribtuo a generalizar.");
			return;
		}

		int index;

		try {
			index = Integer.parseInt(indexStr);
		} catch (NumberFormatException e) {
			Logger.getLogger(Anonimizador.class.getName()).log(Level.ALL, null, e);
			System.out.println("El índice del atributo a generalizar debe ser numérico.");
			return;
		}

		String nIndicesStr = nominalAttributes;
		List<Integer> nIndices = new ArrayList<>();
		StringTokenizer st = new StringTokenizer(nIndicesStr, ",");
		try {
			while (st.hasMoreTokens()) {
				nIndices.add(Integer.parseInt(st.nextToken()));
			}
		} catch (NumberFormatException e) {

			Logger.getLogger(Anonimizador.class.getName()).log(Level.ALL, null, e);
			System.out.println("Los índices de los atributos nominales deben ser numéricos.");
			return;
		}

		for (int i = 0; i < nIndices.size(); ++i) {
			if (nIndices.get(i) < 0 || nIndices.get(i) >= tableModel.getColumnCount()) {
				System.out.println("Los índices de los atributos nominales están fuera de rango.");
				return;
			}
		}

		if (index < 0 || index >= tableModel.getColumnCount()) {
			System.out.println("El índice del atributo nominal a generalizar está fuera de rango.");
			return;
		}

		if (!nIndices.contains(index)) {
			System.out.println("El atributo a generalizar debe ser nominal.");
			return;
		}

		String levelStr = generalizationLevel;
		if (levelStr.isEmpty()) {
			System.out.println("Debe ponerse el nivel hasta el que se quiere generalizar.");
			return;
		}

		int level;

		try {
			level = Integer.parseInt(levelStr);
		} catch (NumberFormatException e) {
			Logger.getLogger(Anonimizador.class.getName()).log(Level.ALL, null, e);
			System.out.println("El nivel hasta el que se quiere generalizar debe ser numérico.");
			return;
		}

		if (level < 0 || level >= t.getHeight()) {
			System.out.println("El nivel hasta el que se quiere generalizar está fuera de rango.");
			return;
		}

		System.out.println(t.getHeight());

		for (int i = 0; i < tableModel.getRowCount(); ++i) {
			String val = (String) tableModel.getValueAt(i, index);
			TaxoTree<String> valT = t.find(val);
			if (valT == null) {
				System.out.println("El atributo seleccionado no corresponde con la taxonomía dada.");
				return;
			}
			int h = valT.getHeight() - 1;
			if (h < level) {
				val = valT.getParentAtHeight(level + 1).getData();
				tableModel.setValueAt(val, i, index);
				System.out.println("val: " + val);
			}
		}
		generateCSV(-1, "ioFiles/filter2.csv");
	}

	/**
	 * This method is in charge of executing the filter three - Generalizer
	 * based on replacement of values by *.
	 *
	 * @param dataFilterThree Listing with the identifier attribute and number
	 * of digits to replace
	 * @author Camilo Benavides
	 */
	private void filterThree(String dataFilterThree) {
		if (!dataFilterThree.equals("")) {

			System.out.println("The parameters for the third filter are NOT empty");

			String params = dataFilterThree;

			StringTokenizer st = new StringTokenizer(params, ",");

			int col = filterThreeProcedure(st);
			generateCSV(col, "ioFiles/filter3.csv");
			tableModel.fireTableDataChanged();

		} else {

			System.out.println("The parameters for the third filter are empty");
		}
	}

	/**
	 * This method is in charge of executing the filter four - Generator based
	 * on micro-aggregation using clustering.
	 *
	 * @param dataFilterFour The quasi-identifier identifiers
	 * @param dataFilterFourI Number of Clusters
	 * @author Jhonan Espejo
	 */
	private void filterFour(String dataFilterFour, String dataFilterFourI) {

		if (!dataFilterFour.equals("") && !dataFilterFourI.equals("")) {

			System.out.println("The parameters for the fourth filter are NOT empty");

			List<String> clustering = new ArrayList<String>();
			String str = dataFilterFour;
			StringTokenizer st = new StringTokenizer(str, ",");

			while (st.hasMoreElements()) {
				clustering.add(st.nextElement().toString());
			}

			try {
				filterFourProcedure(clustering, "filter4.csv", Integer.parseInt(dataFilterFourI));
			} catch (Exception ex) {

				Logger.getLogger(Anonimizador.class.getName()).log(Level.SEVERE, null, ex);
			}

		} else {

			System.out.println("The parameters for the fourth filter are empty");
		}

	}

	/**
	 * This method is in charge of executing the filter five - Delete all values
	 * of an attribute.
	 *
	 * @param dataFilterFive identifier attribute
	 * @author Cristian Lozano
	 */
	private void filterFive(String dataFilterFive) {

		if (!dataFilterFive.equals("")) {

			System.out.println("The parameters for the fifth filter are NOT empty");
			String cuasiID = dataFilterFive;
			int numID = Integer.parseInt(cuasiID);

			for (int i = 0; i < data.size(); i++) {

				data.get(i).set(numID, "");

			}

			tableModel.fireTableDataChanged();
			generateCSV(-1, "ioFiles/filter5.csv");

		} else {

			System.out.println("The parameters for the fifth filter are empty");

		}

	}

	/**
	 * This method contains all the logic of the filter one.
	 *
	 * @param st Tokenized quasi-identifier identifiers
	 * @author Camilo Benavides
	 */
	private void filterOneProcedure(StringTokenizer st) throws IOException {

		List<Integer> myList = new ArrayList<Integer>();
		int contador = 0;
		int acumulado = 0;

		// Filling a list with the tokens
		while (st.hasMoreElements()) {
			myList.add(Integer.valueOf(st.nextToken()));
		}

		// Print to verify that the correct columns name were taken
		for (Integer cuasID : myList) {
			System.out.printf("%-5s,", tableModel.getColumnName(cuasID));
			contador++;
		}

		// Generate the set result for each column - Optional point (not required for the task)
		try {
			PrintWriter writer = new PrintWriter("ioFiles/filterOne-OptionalResult.txt", "UTF-8");
			writer.println("");
			for (int i = 0; i < tableModel.getRowCount(); i++) {
				for (int j = 0; j < tableModel.getColumnCount(); j++) {
					for (Integer cuasID : myList) {

						if (j == cuasID) {
							if (acumulado == myList.size() - 1) {
								writer.printf("%2d: %2s", acumulado + 1, tableModel.getValueAt(i, cuasID));
								acumulado++;
							} else {
								writer.printf("%2d: %2s,", acumulado + 1, tableModel.getValueAt(i, cuasID));
								acumulado++;
							}
						}
						if (acumulado == contador) {
							writer.println("");
							acumulado = 0;
						}
					}
				}
			}
			writer.close();
		} catch (IOException e) {
			System.out.println("There was a problem while trying to generate the results");
		}

		List<Object> dataPerColumn = new ArrayList<Object>();
		List<Integer> countSet = new ArrayList<Integer>();

		//Walktrhoug of the colunm to count the repetitions
		for (Integer cuasID : myList) {
			for (int i = 0; i < tableModel.getColumnCount(); i++) {
				if (i == cuasID) {
					for (int j = 0; j < tableModel.getRowCount(); j++) {
						dataPerColumn.add(tableModel.getValueAt(j, i));
						acumulado++;
					}
					int difVal = diffValues(dataPerColumn);
					dataPerColumn.clear();
					countSet.add(difVal);
				}
			}
		}

		// Creating the fliter one - printing the .TXT
		try {
			PrintWriter writer = new PrintWriter("ioFiles/filter1.txt", "UTF-8");

			for (int j = 0; j < myList.size(); j++) {
				for (int i = 0; i < countSet.size(); i++) {
					if (i == j) {
						if (j == myList.size() - 1) {
							writer.printf("%2d: %2d", myList.get(j), countSet.get(i));
						} else {
							writer.printf("%2d: %2d,", myList.get(j), countSet.get(i));
						}
					}
				}
			}

			writer.close();
		} catch (IOException e) {
			System.out.println("There was a problem while trying to generate the results");
		}

	}

	/**
	 * This method contains all the logic of the filter three.
	 *
	 * @param st Tokenized identifier attribute and number of digits to replace
	 * @author Camilo Benavides
	 */
	private int filterThreeProcedure(StringTokenizer st) {

		List<Integer> myList = new ArrayList<Integer>();
		int contador = 0;
		int acumulado = 0;

		// Filling a list with the tokens
		while (st.hasMoreElements()) {
			myList.add(Integer.valueOf(st.nextToken()));
		}

		int att = myList.get(0);
		int numToBeReplaced = myList.get(1);
		String dato = "";

		//Allocating memory for the array that will contain the replacements
		arrayOfX = new String[tableModel.getRowCount()];

		//Generating the replacements with *
		for (int j = 0; j < tableModel.getColumnCount(); j++) {
			if (j == att) {
				for (int i = 0; i < tableModel.getRowCount(); i++) {

					dato = String.valueOf(tableModel.getValueAt(i, j));
					arrayOfX[i] = replaceWithX(dato, numToBeReplaced);
				}
			}
		}
		return att;
	}

        /**
	 * Este método calcula el mejor número de clusters basado en la cantidad de filas de la tabla y el k esperado
	 * @return int res con el mejor número de clusters
	 * @author Jhonan Espejo
	 */
        public int bestNumberOfClusters(){           
            int rowCount = tableModel.getRowCount();
            int k = Integer.parseInt(jSpinner1.getModel().getValue().toString());
            int res = rowCount/k;
            res = (int) (res * 0.8);
            return res;
        }
        
	/**
	 * This method contains all the logic of the filter four.
	 *
	 * @param cuasi The quasi-identifier identifiers
	 * @param name The name of the output CSV
	 * @param nCl The number of Clusters
	 * @throws java.lang.Exception
	 * @author Jhonan Espejo
	 */
	public void filterFourProcedure(List<String> cuasi, String name, int nCl) throws Exception {

		SimpleKMeans kmeans = new SimpleKMeans();
		kmeans.setSeed(10);

		kmeans.setPreserveInstancesOrder(true);
		kmeans.setNumClusters(nCl);

		generateCSV(-1, "dateBeforeFilter4Temp.csv");

		ConverterUtils.DataSource source = new ConverterUtils.DataSource("dateBeforeFilter4Temp.csv");
		Instances data = source.getDataSet();

		RemoveType af = new RemoveType();
		af.setInputFormat(data);
		data = Filter.useFilter(data, af);

		kmeans.buildClusterer(data);

		int[] assignments = kmeans.getAssignments();

		int i = 0;
		Instances centroids = kmeans.getClusterCentroids();
		String outputFile = name;
		boolean alreadyExists = new File(outputFile).exists();

		if (alreadyExists) {
			File ficheroPunto4 = new File(outputFile);
			ficheroPunto4.delete();
		}
		CsvWriter csvOutput = new CsvWriter(new FileWriter(outputFile, true), ',');
		CsvReader csv_import = new CsvReader("dateBeforeFilter4Temp.csv");

		csv_import.readRecord();
		for (int k = 0; k < csv_import.getColumnCount(); k++) {
			csvOutput.write(csv_import.get(k));
		}
		csvOutput.endRecord();

		i = 0;
		while (csv_import.readRecord()) {
                        System.out.println((centroids.instance(assignments[i])).numAttributes());
			for (int k = 0; k < csv_import.getColumnCount(); k++) {
				if (enteroEnLista(cuasi, k)) {
                                        String cen = (centroids.instance(assignments[i])).toString(k);
                                        Object ob = cen;
					csvOutput.write(cen);
                                        this.data.get(i).set(k, ob);
				} else {
					csvOutput.write(csv_import.get(k));
				}
			}
			csvOutput.endRecord();
			i++;
		}
		csv_import.close();
		File fichero = new File("dateBeforeFilter4Temp.csv");
		fichero.delete();
		tableModel.fireTableDataChanged();
	}

	/**
	 * Este metodo valida si un numero dado esta incluido en una lista de
	 * cadenas de caracteres.
	 *
	 * @param lista es una lista de cadenas de caracteres y en ella se va a
	 * buscar un numero.
	 * @param numero es un entero y se desea saber si esta incluido en una
	 * lista.
	 * @return boolean true si el parametro 'numero' fue encontrado en el
	 * parametro 'lista'.
	 */
	public boolean enteroEnLista(List<String> lista, int numero) {
		for (String p : lista) {
			if (Integer.parseInt(p) == numero) {
				return true;
			}
		}
		return false;
	}
        
        public void anonymizationWithClusters(){
            //calculateKAnonimity
        }

	/**
	 * This method contains all the logic to generate output CSV files.
	 *
	 * @param colunm the column that was modified
	 * @param filePath the name of the output CSV
	 * @author Camilo Benavides
	 */
	private void generateCSV(int colunm, String filePath) {

		try {
			PrintWriter writer = new PrintWriter(filePath, "UTF-8");

			//Print the headers on the new CSV
			for (int j = 0; j < tableModel.getColumnCount(); j++) {
				if (j != tableModel.getColumnCount() - 1) {
					writer.printf(tableModel.getColumnName(j) + ",");
				} else {
					writer.printf(tableModel.getColumnName(j) + "");
					writer.println("");
				}
			}

			//Print the data of the new CSV, with transformations
			for (int i = 0; i < tableModel.getRowCount(); i++) {
				for (int j = 0; j < tableModel.getColumnCount(); j++) {
					if (j == colunm) {
						if (j != tableModel.getColumnCount() - 1) {
							writer.printf(arrayOfX[i] + ",");
						} else {
							writer.printf(arrayOfX[i] + "");
							writer.println("");
						}
					} else {
						if (j != tableModel.getColumnCount() - 1) {
							writer.printf(tableModel.getValueAt(i, j) + ",");
						} else {
							writer.printf(tableModel.getValueAt(i, j) + "");
							writer.println("");
						}
					}
				}
			}

			writer.close();
		} catch (IOException e) {
			System.out.println("There was a problem while trying to generate the results");
		}

	}

	/**
	 * This method contains all the logic for parsing the taxonomy file.
	 *
	 * @param filePath the absolute path to the taxonomy file.
	 * @return a {@code TaxoTree<String>} with the loaded taxonomy.
	 * @author David Villamizar
	 */
	public TaxoTree<String> parseTaxonomyFile(String filePath) {
		TaxoTree<String> t = new TaxoTree<>("Root");
		List<String> lines;
		try {
			lines = Files.readAllLines(new File(filePath).toPath());
			for (int i = 0; i < lines.size(); ++i) {
				String line = lines.get(i);
				if (line.charAt(0) != '\t') {
					List<String> lineage = new ArrayList<>();
					TaxoTree<String> t1 = new TaxoTree<>();
					lineage.add(line);
					int j = 1;
					for (; j + i < lines.size() && lines.get(i + j).charAt(0) == '\t'; ++j) {
						lineage.add(lines.get(i + j).substring(j, lines.get(i + j).length()));
					}
					i += j - 1;
					t1.buildFromLineage(lineage);
					t.addChild(t1);
				}
			}
		} catch (IOException ex) {
			Logger.getLogger(Anonimizador.class.getName()).log(Level.SEVERE, null, ex);
			System.out.println("Error leyendo el archivo.");
			return null;
		}
		return t;
	}


	/* ------------------ MAIN ------------------ */
	/**
	 * @param args the command line arguments
	 */
	public static void main(String args[]) {
		/* Create and display the form */
		java.awt.EventQueue.invokeLater(new Runnable() {
			public void run() {
				new Anonimizador().setVisible(true);
			}
		});
	}


	/* ------------------ Utility Methods Declaration ------------------ */
	/**
	 * This method contains all the logic used to replace with ***
	 *
	 * @param att the attribute that will be replaced with
	 * @param numToBeReplaced how many * are needed to be put
	 */
	private String replaceWithX(String att, int numToBeReplaced) {

		int cont = 0;
		char[] buff = att.toCharArray();

		if (numToBeReplaced <= att.length()) {

			for (int i = att.length(); cont < numToBeReplaced; i--) {

				System.out.println("" + att.charAt(i - 1));
				buff[i - 1] = '*';
				cont++;

			}
		} else {

			System.out.println("se sale del rango");

		}

		return String.valueOf(buff);

	}

	/**
	 * Counts the repetitions of values in one column.
	 *
	 * @param numArray the data set of the column
	 * @return the number of different values
	 */
	public static int diffValues(List<Object> numArray) {
		int numOfDifferentVals = 0;

		ArrayList<Object> diffNum = new ArrayList<>();

		for (Object item : numArray) {
			if (!diffNum.contains(item)) {
				diffNum.add(item);
			}
		}

		if (diffNum.size() == 1) {
			numOfDifferentVals = 0;
		} else {
			numOfDifferentVals = diffNum.size();
			diffNum.clear();
		}

		return numOfDifferentVals;
	}

	/**
	 * Calculates the minimim K anonimity currently fullfiled for the rows in
	 * this.data.
	 *
	 * @return the minimim K anonimity for this.data.
	 */
	private int calculateKAnonimity() {
		int minK = Integer.MAX_VALUE;
		BitSet visited = new BitSet(data.size());
		for (int i = 0; i < data.size(); i++) {
			if (!visited.get(i)) {
				visited.set(i, true);
				int currK = 1;
				for (int j = i + 1; j < data.size(); j++) {
					if (!visited.get(j) && data.get(i).equals(data.get(j))) {
						currK++;
						visited.set(j, true);
					}
				}
				if (currK < minK) {
					minK = currK;
				}
			}
		}
		return minK;
	}
	
	/**
	 * Calculates the minimim K anonimity currently fullfiled for the rows in
	 * this.data, for given the quasi-identifiers.
	 * 
	 * @param quasiIds List of integers with the quasi-identifier indices.
	 * @return the minimim K anonimity for this.data.
	 */
	private int calculateKAnonimity(List<Integer> quasiIds) {
		int minK = Integer.MAX_VALUE;
		BitSet visited = new BitSet(data.size());
		for (int i = 0; i < data.size(); i++) {
			if (!visited.get(i)) {
				visited.set(i, true);
				int currK = 1;
				List<Object> row1 = new ArrayList<>();
				for (int j = 0; j < quasiIds.size(); j++) {
					row1.add(data.get(i).get(quasiIds.get(j)));
				}
				for (int j = i + 1; j < data.size(); j++) {
					if (!visited.get(j)) {
						List<Object> row2 = new ArrayList<>();
						for (int k = 0; k < quasiIds.size(); k++) {
							row2.add(data.get(j).get(quasiIds.get(k)));
						}
//						boolean isEqual = true;
//						for (int k = 0; k < row1.size() && isEqual; k++) {
//							if (!row1.get(k).equals(row2.get(k))) {
//								isEqual = false;
//							}
//						}
//						if (isEqual) {
						if (row1.equals(row2)) {
							currK++;
							visited.set(j, true);
						}
					}
				}
				if (currK < minK) {
					minK = currK;
				}
			}
		}
		return minK;
	}

	/**
	 * Utility class for the JFileChooser, applys a filter that accepts only
	 * files with the .csv extension.
	 *
	 * @class CSVFileFilter
	 */
	class CSVFileFilter extends javax.swing.filechooser.FileFilter {

		@Override
		public boolean accept(File file) {
			// Allow only directories, or files with ".csv" extension
			return file.isDirectory() || file.getAbsolutePath().endsWith(".csv");
		}

		@Override
		public String getDescription() {
			// This description will be displayed in the dialog,
			// hard-coded = ugly, should be done via I18N
			return "Archivos CSV (*.csv)";
		}
	}

	/**
	 * Utility class for the JFileChooser, applys a filter that accepts only
	 * files with the .txt extension.
	 *
	 * @class TXTFileFilter
	 */
	class TXTFileFilter extends javax.swing.filechooser.FileFilter {

		@Override
		public boolean accept(File file) {
			// Allow only directories, or files with ".csv" extension
			return file.isDirectory() || file.getAbsolutePath().endsWith(".txt");
		}

		@Override
		public String getDescription() {
			// This description will be displayed in the dialog,
			// hard-coded = ugly, should be done via I18N
			return "Archivos de texto (*.txt)";
		}
	}


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu Open;
    private javax.swing.JButton jButton5;
    private javax.swing.JButton jButton6;
    private javax.swing.JFileChooser jFileChooser1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JSpinner jSpinner1;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTable jTable2;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField3;
    private javax.swing.JTree jTree1;
    // End of variables declaration//GEN-END:variables
}
